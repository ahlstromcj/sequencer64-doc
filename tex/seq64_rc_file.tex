%-------------------------------------------------------------------------------
% seq64_rc_file
%-------------------------------------------------------------------------------
%
% \file        seq64_rc_file.tex
% \library     Documents
% \author      Chris Ahlstrom
% \date        2015-08-31
% \update      2016-05-20
% \version     $Revision$
% \license     $XPC_GPL_LICENSE$
%
%     Provides the rc_file.
%
%-------------------------------------------------------------------------------

\section{Sequencer64 Configuration File}
\label{sec:seq64_rc_file}

   \index{sequencer64.rc}
   \index{[sequencer64.rc]}   % for convenience
   The \textsl{Sequencer64} configuration file originally was \texttt{.seq24rc},
   and it was stored in the user's \texttt{\$HOME} directory.
   This is the same name used by \textsl{Seq24}, so we created an new file
   to take its place, with a fall-back to the original file-name if the new
   file does not exist, or if \textsl{Sequencer64} is running in
   \index{legacy mode}
   legacy mode.

   After you run \textsl{Sequencer64} for the first time (in non-legacy
   mode), it will generate a \texttt{sequencer64.rc} file in your home
   directory:

   \begin{verbatim}
      /home/ahlstrom/.config/sequencer64/sequencer64.rc
   \end{verbatim}

   It contains the the data for remote MIDI control, keyboard
   control, and MIDI clock.

   \textsl{Sequencer64} will overwrite the \texttt{sequencer6.4rc} file upon
   quitting.  One should therefore quit \textsl{Sequencer64} before doing
   manual modifications to the \texttt{sequencer64.rc} file.

\subsection{Sequencer64 / MIDI Control Section}
\label{subsec:seq64_rc_file_midi_control}

   Like \textsl{Seq24}, \textsl{Sequencer64} provides a way to control the
   application to some extent via a MIDI controller, such as a MIDI keyboard or
   a MIDI pad device.  The current section describes this feature;
   additional resources can be found a \url{linuxaudio.org}
   (\cite{midicontrol}).

   \index{[midi-control]}
   For each pattern, we can set up MIDI events to turn a 
	pattern on, off, or to toggle it.  This setup is in the 
   MIDI Control section of \texttt{sequencer64.rc}, and begins with an
   "INI" group marker \texttt{[midi-control]}.

% OR is it the current screen set and a set of mute groups???

   The MIDI control setup resembles a matrix.
   The matrix represents the first two screen-sets
   (entries are numbered from 0
   to 63) and some control keys (entries from 64 to 73).  The three fields,
   each between the brackets, on each line, correspond to a MIDI filter... if
   the incoming MIDI event matches the filter it will \textsl{toggle} (first
   field), \textsl{enable} (second field) or \textsl{disable} (third field) the
   sequence.
	
   The MIDI Control section is explicitly broken into subsections, though those
   subsections are marked with comment-lines for better comprehensibility.  The
   subsections of the MIDI Control section are:

   \begin{enumber}
      \item \textbf{pattern group}.  Consists of 32 lines, one for each
         pattern box shown in the Pattern window.
      \item \textbf{mute in group}.  Consists of 32 lines, one for each
         pattern box shown in the Pattern window.
      \item \textbf{automation group}.  Each item in this group consists of
         one line.
         \begin{enumber}
            \item \textbf{bpm up}. Consists of one line.
            \item \textbf{bpm down}. Consists of one line.
            \item \textbf{screen-set up}. Consists of one line.
            \item \textbf{screen-set down}. Consists of one line.
            \item \textbf{mod replace}. Consists of one line.
            \item \textbf{mod snapshot}. Consists of one line.
            \item \textbf{mod queue}. Consists of one line.
            \item \textbf{mod gmute}. Consists of one line.
            \item \textbf{mod glearn}. Consists of one line.
            \item \textbf{screen-set play}. Consists of one line.
         \end{enumber}
   \end{enumber}

   We see the following lines in the MIDI Control section, which is broken
   into groups or subsections marked by comments:

   \begin{verbatim}
      [midi-control]
      74      # MIDI controls count

      # pattern group
       0  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]            
       1  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]          
       2  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      ...     ...            ...              ...
      31  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]    

      # mute in group section:
      32  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      33  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      ...     ...            ...              ...
      63  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # bpm up:
      64  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      # bpm down:
      65  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      # screen set up:
      66  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      # screen set down:
      67  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      # mod replace:
      68  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      # mod snapshot:
      69  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      # mod queue:
      70  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      # mod gmute:
      71  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      # mod glearn:
      72  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      # screen set play:
      73  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
   \end{verbatim}

   The number (74) is the number of lines in the MIDI Control section.

   The first number is the pattern/sequence number in the main window, which
   ranges from 0 to 31.  Each set of brackets corresponds to a MIDI filter.
   The MIDI filter in the leftmost brackets is the \textsl{toggle} filter.
   The MIDI filter in the middles brackets is the \textsl{on} filter.
   The MIDI filter in the rightmost brackets is the \textsl{off} filter.
   If the incoming MIDI event matches the filter, it will either [toggle],
   [on], or [off] the pattern/sequence, respectively.

   The layout of each filter inside the brackets is as follows:

      [OPR INV STAT D1 D2min D2max]

   where

   \begin{itemize}
      \item \textbf{OPR} = \textbf{on/off}
      \item \textbf{INV} = \textbf{inverse}
      \item \textbf{STAT} = \textbf{MIDI status byte} (channel ignored) 
      \item \textbf{D1} = \textbf{data1}
      \item \textbf{D2min} = \textbf{data2 min}
      \item \textbf{D2max} = \textbf{data2 max}
   \end{itemize}

   If \textbf{on/off} is set to 1, it will match the incoming MIDI against
   the \textbf{MIDI status byte} pattern and perform the action
   (on/off/toggle) if the data falls in the range specified.  All values are
   in decimal.

	The \textbf{inverse} field will make the pattern perform the opposite 
   action (\textsl{off} for \textsl{on}, \textsl{on} for \textsl{off}) if
   the data falls outside the specified range.  This is cool because one can
   map several sequences to a knob or fader.

   The \textbf{MIDI status byte} field a MIDI status byte number in decimals.
   The channel nybble of this byte is ignored.
   One can look the possible status values up in the MIDI messages tables; the
   relevant data can be found at \cite{midicontroltable}.
   As the channel on which the events are sent is ignored, one should
   always use the values for channel 1.  That is, 0.

	The last three fields describe the range of data that will match.
   The \textbf{data1} field provides the actual MIDI event message number to
   detect, in decimal.
   This item could be a Note On/Off event or a Control/Mode change event,
   for example.

   The \textbf{data2 min} field is the minimum value of the event
   for the filter to match. For Note On/Off events,
   this would be the velocity value, for example.

   The \textbf{data2 max} field is the maximum value of the event
   for the filter to match.

\subsubsection{Sequencer64 / MIDI Control Pattern Group}
\label{subsubsec:seq64_rc_file_midi_control_pattern_group}

   Complex?  Here is an example for the some of the first 32 lines, which
   comprise the \textsl{pattern group}.
   The following is an example of responding
   to Note On events for note 0, with any velocity, to turn the pattern on,
   and Note Off events for note 0, and any velocity, to turn the pattern
   off.

   \begin{verbatim}
	          Toggle                 On                      Off
        1 [0 0 0 0 0 0]      [1 0  144 0 0 127]       [1 0 128 0 0 127]
   \end{verbatim}

   The \textbf{Toggle} field is off (inactive).  All values are 0.
   There is no way to use MIDI control to toggle sequence 1.

   The \textbf{On} value is on (1 = active).
   The \textbf{nverse} value is off (0 = inactive).
   The \textbf{MIDI status byte}, 144, which is 0x90 (hex), which is a Note On
   event on channel 0.  However, the channel is ignored.
   The \textbf{data1} values sets the actual Note value to 0, meaning the
   lowest possible MIDI note (pitch) value.
   \textbf{data2 min} value sets
   the minimum value to 0, and
   \textbf{data2 max} sets the maximum value to 127.
   Thus, receiving any Note On velocity for note 0 will turn sequence 1
   \textsl{on}.

   The \textbf{Off} field is on (active), and it is set up the same way as the
   \textbf{On} field, except that the status message is
   128, which is 0x80 (hex), which is a Note Off event on channel 0.
   Thus, receiving any Note Off velocity for note 0 will turn sequence 1
   \textsl{off}.

   So, basically, pattern 1 starts when any Note On for MIDI note 0
   is received, and it stops when any Note Off for MIDI note 0 is received.  
   One can easily extend this so that Note On/Off values from 0 to 31
   control the corresponding pattern slot.

   The following example would map a row of sequences to one knob sending
   out changes for Control Code 1:

   \begin{verbatim}
	          Toggle                 On                      Off
        0 [0 0 0 0 0 0]      [1 1 176 1   0   15]     [0 0 0 0 0 0]
        1 [0 0 0 0 0 0]      [1 1 176 1  16   31]     [0 0 0 0 0 0]
        2 [0 0 0 0 0 0]      [1 1 176 1  32   47]     [0 0 0 0 0 0]
        3 [0 0 0 0 0 0]      [1 1 176 1  48   63]     [0 0 0 0 0 0]
        4 [0 0 0 0 0 0]      [1 1 176 1  64   79]     [0 0 0 0 0 0]
        5 [0 0 0 0 0 0]      [1 1 176 1  80   95]     [0 0 0 0 0 0]
        6 [0 0 0 0 0 0]      [1 1 176 1  96  111]     [0 0 0 0 0 0]
        7 [0 0 0 0 0 0]      [1 1 176 1 112  127]     [0 0 0 0 0 0]
   \end{verbatim}

   The \textbf{on} field is on (active).  Inverse is active.  The
   \textbf{MIDI status byte}, 176, is 0xB0 (hex), which is a Control Change
   event (channel ignored).  \textbf{data1} is 1, which is the controller
   number for a Modulation Wheel.  The \textbf{data2} ranges are set so
   that, as the controller data increases (as the modulation-wheel knob is
   turned, so to speak), patterns 0 through 7 come on one at a time until
   all are running.

\subsubsection{Sequencer64 / MIDI Control Mute In Group}
\label{subsubsec:seq64_rc_file_midi_control_mute_in_group}

   \index{mute-in group}
   \index{[midi-control]!mute-in group}
   This section controls 32 groups of mutes in the same way as 
	defined for \texttt{[midi-control]}, and is in fact placed in the
   \texttt{[midi-control]} section.

   A group is a set of patterns that can toggle their playing state
   together.  Every group contains all 32 sequences in the active screen set
   (see after).

   So, this part of the MIDI Control section is used for muting and unmuting
   (and toggling) a group of patterns.

\subsubsection{Sequencer64 MIDI Control Automation Group}
\label{subsubsec:seq64_rc_file_midi_control_automation_group}

   \index{automation group}
   \index{[midi-control]!automation group}

   \setcounter{ItemCounter}{0}      % Reset the ItemCounter for this list.

   \itempar{bpm up}{[midi-control]!bpm up}
   Increases the BPM (speed) of the sequencer based on MIDI input.

   \itempar{bpm down}{[midi-control]!bpm down}
   Decreases the BPM (speed) of the sequencer based on MIDI input.

   \itempar{screen-set up}{[midi-control]!screen-set up}
   Increases the active screen-set of the sequencer based on MIDI input.

   \itempar{screen-set down}{[midi-control]!screen-set down}
   Decreases the active screen-set of the sequencer based on MIDI input.

   \itempar{mod replace}{[midi-control]!mod replace}
   This item provides a way to automate replacement.
   TODO.
   \index{todo!explain replacement}
   Explain the concept of replacement.

   \itempar{mod snapshot}{[midi-control]!mod snapshot}
   This item provides a way to automate snapshots.
   TODO.
   \index{todo!explain snapshots}
   Explain the concept of snapshots.

   \itempar{mod queue}{[midi-control]!mod queue}
   This item provides a way to automate queueing.
   TODO.
   \index{todo!explain queue}
   Explain the concept of queue.

   \itempar{mod gmute}{[midi-control]!mod gmute}
   \index{group!muting}
   This item provides a way to automate group-muting.
   Explain the concept of snapshots.

   \itempar{mod glearn}{[midi-control]!mod glearn}
   \index{group!learning}
   This item provides a way to automate group-learning.
   TODO.
   \index{todo!group learning}
   Explain the concept of group-learning.

   \itempar{screen-set play}{[midi-control]!screen-set play}
   This item provides a way to automate screen set play.
   TODO.
   \index{todo!explain queue}
   Explain the concept of screen set play.

\subsection{Sequencer64 / Mute-Group Section}
\label{subsec:seq64_rc_file_mute_group}
     
   This section is delimited by the \texttt{[mute-group]} construct.
   It controls 32 groups of mutes in the same way as defined for
   \texttt{[midi-control]}. A group is set of sequences that can toggle their
   playing state together.  Every group contains all 32 sequences in the
   active screen set.

   \begin{verbatim}
      [mute-group]
      1024    # group mute value count
      0 [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0]
      1 [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0]
      2 [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0]
      ...      ...               ...               ...               ...
      31 [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0]
   \end{verbatim}

   The initial number, 1024 is probably the total count of 32 x 32 sequences.

   In this group are the definitions of the state of the 32 sequences
   in the playing screen set when a group is selected.
   Each set of brackets defines a group:
   
   \begin{verbatim}
      [state of the first 8 sequences] [second 8] [third 8] [fourth 8]
   \end{verbatim}

   After the list of sequences and their MIDI events, one can 
   set \textsl{Sequencer64} to handle MIDI events and change some more settings
   in \texttt{sequencer64.rc}.

\subsection{Sequencer64 / MIDI-Clock Section}
\label{subsec:seq64_rc_file_midi_clock}

   \index{[midi-clock]}
   The MIDI Clock fields will contain the clocking state from the last 
   time \textsl{Sequencer64} was run.  Turn off the clock with a 0, or on
   with a 1.
   This section has 16 entries, one for each MIDI output buss that
   \textsl{Sequencer64} supports.

   This configuration item is the same as the 
   \textbf{MIDI Clock} tab described in
   \paragraphref{paragraph:seq64_menu_file_options_midi_clock}
   
   Here is the format:

   \begin{verbatim}
      [midi-clock]
      16
       0 0  #  [1] seq24 1
       1 0  #  [2] seq24 2
       2 0  #  [3] seq24 3
       3 0  #  [4] seq24 4
       4 0  #  [5] seq24 5
       5 0  #  [6] seq24 6
       6 0  #  [7] seq24 7
       7 0  #  [8] seq24 8
       8 0  #  [9] seq24 9
       9 0  # [10] seq24 10
      10 0  # [11] seq24 11
      11 0  # [12] seq24 12
      12 0  # [13] seq24 13
      13 0  # [14] seq24 14
      14 0  # [15] seq24 15
      15 0  # [16] seq24 16
   \end{verbatim}

That sample would be written one had started up \textsl{Sequencer64} in
manual-alsa-mode.  On our system, where we have Timidity running, and
erroneously have also specified 3 MIDI busses that we do not have, in the
\texttt{sequencer64.usr} file:

   \begin{verbatim}
      [midi-clock]
      5    # number of MIDI clocks/busses
      # Output buss name: [0] 14:0 2x2 A (SuperNova,Q,TX81Z,DrumStation)
      0 0  # buss number, clock status
      # Output buss name: [1] 128:0 2x2 B (WaveStation,ESI-2000,MV4,ES-1,ER-1)
      1 0  # buss number, clock status
      # Output buss name: [2] 128:1 PCR-30 (303)
      2 0  # buss number, clock status
      # Output buss name: [3] 128:2 TiMidity port 2
      3 0  # buss number, clock status
      # Output buss name: [4] 128:3 TiMidity port 3
      4 0  # buss number, clock status
   \end{verbatim}

\subsection{Sequencer64 / Keyboard Control Section}
\label{subsec:seq64_rc_file_keyboard_control}
        
   \index{[keyboard control]}
   The keyboard control is a dump of the keys that \textsl{Sequencer64}
   recognises, and each key's corresponding sequence number.
   Note that the first number corresponds to the number of sequences in
   the active screen set.

   \begin{verbatim}
      [keyboard-control]
      32     # number of keys
      # Key #  Sequence #   Key name
      44  31        # comma
      49  0         # 1
      50  4         # 2
      51  8         # 3
      52  12        # 4
      53  16        # 5
      54  20        # 6
      55  24        # 7
      56  28        # 8
      97  2         # a
      98  19        # b
      99  11        # c
      100  10       # d
      101  9        # e
      102  14       # f
      103  18       # g
      104  22       # h
      105  29       # i
      106  26       # j
      107  30       # k
      109  27       # m
      110  23       # n
      113  1        # q
      114  13       # r
      115  6        # s
      116  17       # t
      117  25       # u
      118  15       # v
      119  5        # w
      120  7        # x
      121  21       # y
      122  3        # z
   \end{verbatim}

\subsection{Sequencer64 / Keyboard Group Section}
\label{subsec:seq64_rc_file_keyboard_group}

   \index{[keyboard-group]}
   This section is the same as
   \textbf{[keyboard-control]}, but to control groups.
   The keyboard group specifies more automation for the application.  The
   first number specifies the Key number, and the second number specifies
   the Group number.

   Additional control:

   \begin{enumber}
   	\item \textbf{\# bpm up and down}.
	      Keys to control BPM (beats per minute).
      \item \textbf{\# screen set up and down}.
	      Keys for changing the active screenset.
      \item \textbf{\# group functionality on, off, learn}.
         \index{group learn}
	      Note that the group learn key is a modifier key to be held while 
         \index{group toggle}
         pressing a group toggle key.
      \item \textbf{\#replace, queue, snapshot\_1, snapshot\_2, keep queue}.
         These are the other modifier keys explained in section 3a.
   \end{enumber}

	To see the required key codes when pressed, run \texttt{seq24} with
   the \texttt{--show\_keys}.

   Some keys should not be assigned to control sequences in \textsl{Sequencer64} as
   they are already assigned in the \textsl{Sequencer64} menu (with \texttt{Ctrl}). 

   This configuration item is the same as the 
   \textbf{Keyboard} tab described in
   \sectionref{paragraph:seq64_menu_file_options_keyboard}.

   \begin{verbatim}
      [keyboard-group]
      # Key #, group # 
      32
      33  0         # exclam
      34  1         # quotedbl
      35  2         # numbersign
      36  3         # dollar
      37  4         # percent
      38  5         # ampersand
      40  7         # parenleft
      47  6         # slash
      59  31        # semicolon
      65  16        # A
      66  28        # B
      67  26        # C
      68  18        # D
      69  10        # E
      70  19        # F
      71  20        # G
      72  21        # H
      73  15        # I
      74  22        # J
      75  23        # K
      77  30        # M
      78  29        # N
      81  8         # Q
      82  11        # R
      83  17        # S
      84  12        # T
      85  14        # U
      86  27        # V
      87  9         # W
      88  25        # X
      89  13        # Y
      90  24        # Z
      39 59         # bpm up, down: apostrophe semicolon
      93 91 65360   # screen set up, down, play: bracketright bracketleft Home
      236 39 65379  # group on, off, learn: igrave apostrophe Insert
      # replace, queue, snapshot_1, snapshot 2, keep queue:
      65507 65508 65513 65514 92  # Control_L Control_R Alt_L Alt_R backslash
      1             # show_ui_sequence_key (1=true/0=false)
      32            # space start sequencer
      65307         # Escape stop sequencer
      0 #  show sequence numbers (1 = true / 0 = false);  ignored in legacy mode
   \end{verbatim}

\subsection{Sequencer64 / JACK Transport}
\label{subsec:seq64_rc_file_jack_transport}

   \index{[jack-transport]}
   The JACK Transport options are also command-line options, as indicated in
   the comments below.

   This configuration item is the same as the 
   \textbf{Jack Sync} tab described in
   \sectionref{paragraph:seq64_menu_file_options_jack_sync}.

   \index{--jack\_transport}
   \index{--jack\_master}
   \index{--jack\_master\_cond}
   \index{--jack\_start\_mode}
   \begin{verbatim}
      [jack-transport]

      # jack_transport - Enable slave sync with JACK Transport.
      0

      # jack_master - Sequencer64 attempts to serve as JACK Master.
      0

      # jack_master_cond - Sequencer64 is master if no other master exists.
      0

      # jack_start_mode
      # 0 = Playback in live mode. Allows muting and unmuting of loops.
      # 1 = Playback uses the song editor's data.
      1
   \end{verbatim}

   Please note that only \textsl{one} of
   jack\_transport, jack\_master, and jack\_master\_cond should be selected
   (set to 1) at a time.

\subsection{Sequencer64 / Other Sections}
\label{subsec:seq64_rc_file_other_midi}

   \index{[midi-clock-mod-ticks]}
   This configuration item is the same as the
   \textbf{Clock Start Modulo} option described in
   \paragraphref{paragraph:seq64_menu_file_options_midi_clock}.

   \begin{verbatim}
      [midi-clock-mod-ticks]
      64
   \end{verbatim}

   \index{[midi-input]}
   This configuration item is the same as the 
   \textbf{MIDI Input} tab described in
   \paragraphref{paragraph:seq64_menu_file_options_midi_input}.
   The "1" is undoubtedly a record count, and would equal the number of
   supported input ports.
   This "rc" entry here has two variables; the first is the record number or
   port number, and the second number indicates whether it is disabled (0),
   or enabled (1).

   \begin{verbatim}
      [midi-input]
      1   # number of MIDI busses
      # [0] 14:0 2x2 A (SuperNova,Q,TX81Z,DrumStation)
      0 0
   \end{verbatim}

   There is no user-interface item for the following value, but
   it does correspond to the \texttt{--manual\_alsa\_ports} command-line
   option.

   \index{[manual-alsa-ports]}
   \begin{verbatim}
      # set to 1 if you want seq24 to create its own alsa ports and
      # not connect to other clients

      [manual-alsa-ports]
      1
   \end{verbatim}

   \index{jack!manual-alsa-ports}
   Turning on the manual-alsa-ports option is necessary if one
   wants to use \textsl{Sequencer64} with JACK.
   It will create ports as per the settings in the "user" configuration file's
   \texttt{user-midi-bus-definitions} and \texttt{user-midi-bus-N} sections.
   These definitions can be used by JACK for connection, and these definitions
   can be used to specifically rename the ports that exist in the system.
   However, this option is misleading if one wants to have access to the
   actual ALSA ports that exist on the system.
   The next option gets around that issue.

   \index{[reveal-alsa-ports]}
   \begin{verbatim}
      # Set to 1 to have sequencer64 ignore any system port names
      # declared in the 'user' configuration file.  Use this option if
      # you want to be able to see the port names as detected by ALSA.

      [reveal-alsa-ports]
      1   # flag for reveal ALSA ports
   \end{verbatim}

   \index{jack!reveal-alsa-ports}
   Turning on the reveal-alsa-ports option is necessary if one
   wants to see the actual ALSA port names defined by the system.
   It will ignore the settings in the "user" configuration file's
   \texttt{user-midi-bus-definitions} and \texttt{user-midi-bus-N} sections.
   If this option is turned on, the definitions in the
   "user" configuration file are \textsl{not} read from that file.

   \index{[interaction-method]}
   This configuration item is the same as the 
   \textbf{Mouse} tab described in
   \paragraphref{paragraph:seq64_menu_file_options_mouse}.

   \index{[interaction-method]}
   \begin{verbatim}
      # 0 - 'seq24' (original seq24 method)
      # 1 - 'fruity' (similar to a certain fruity sequencer we like)

      [interaction-method]
      0

      # Set to 1 to allow seq24 to stay in note-adding mode when
      # the right-click is released while holding the Mod4 (Super or
      # Windows) key.
      0
   \end{verbatim}

   \textbf{New:}
   \index{new!Mod4 edit-lock}
   There is now an option to use the Mod4 (Super, or Windows) key in the
   Pattern Editor to lock the editing of a note.  When this mode is enabled,
   and Mod4 is pressed while the mouse right-button is released, the
   editing pencil icon remains, and notes can be added.  This feature is
   useful for crippled trackpads and trackpad drivers that cannot provide
   two simultaneous button presses.

   \index{[lash-session]}
   This configuration item is the same as the
   \texttt{--lash} or \texttt{--no-lash} options described in
   \sectionref{sec:seq64_man_page}.
   If set to 0, LASH session support is disabled.
   If set to 1, LASH session support is enabled.
   However, if LASH support is not built into the application, neither option
   has any effect -- there is no LASH support.  
   To determine if LASH support is built in, run sequencer64 from the command
   line with the \texttt{--help} option, and see if LASH is mentioned.

   \begin{verbatim}
      [lash-session]
      # Set the following value to 0 to disable LASH session management.
      # Set the following value to 1 to enable LASH session management.
      # This value will have no effect is LASH support is not built into
      # the application.  Use the --help option to see if LASH is part of
      # the options list.
      1     # LASH session management support flag
   \end{verbatim}

   \index{[auto-option-save]}
   This new item determines if the "rc" configuration file is saved
   upon exit of \textsl{Sequencer64}.  The legacy behavior is to save it,
   which can sometimes be inconvenient when one is just trying out some
   command-line options.

   \begin{verbatim}
      [auto-option-save]
      # Set the following value to 0 to disable the automatic saving of the
      # current configuration to the 'rc' file.  Set it to 1 to
      # follow legacy seq24 behavior of saving the configuration at exit.
      # Note that, if auto-save is set, many of the command-line settings,
      # such as the JACK/ALSA settings, are then saved to the configuration,
      # which can confuse one at first.  Also note that one currently needs
      # this option set to 1 to save the configuration, as there is not a
      # user-interface control for it at present.
      0     # auto-save-options-on-exit support flag
   \end{verbatim}

   The following item refers to the last directory in which one opened or
   saved a MIDI file.

   \index{[last-used-dir]}
   \begin{verbatim}
      [last-used-dir]

      # Last used directory.

      /home/ahlstrom/Home/ca/mls/git/sequencer64/contrib/midi/
   \end{verbatim}

%-------------------------------------------------------------------------------
% vim: ts=3 sw=3 et ft=tex
%-------------------------------------------------------------------------------
